(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{387:function(e,t,i){"use strict";i.r(t);var a=i(11),o=Object(a.a)({},(function(){var e=this,t=e.$createElement,i=e._self._c||t;return i("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[i("h1",{attrs:{id:"distributed-system"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#distributed-system"}},[e._v("#")]),e._v(" Distributed System")]),e._v(" "),i("h2",{attrs:{id:"concepts"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#concepts"}},[e._v("#")]),e._v(" Concepts")]),e._v(" "),i("ol",[i("li",[i("p",[e._v("clock")]),e._v(" "),i("ul",[i("li",[e._v("logical clock — a kind of monotonically growing counter")]),e._v(" "),i("li",[e._v("physical clock, aka wall clocks — bound to physical time, accessible through process-local means")])])]),e._v(" "),i("li",[i("p",[e._v("distributed algorithm goals")]),e._v(" "),i("ul",[i("li",[e._v("Coordination — A process that supervises the actions and behavior of several workers.")]),e._v(" "),i("li",[e._v("Cooperation — Multiple participants relying on one another for finishing their tasks.")]),e._v(" "),i("li",[e._v("Dissemination — Processes cooperating in spreading the information to all interested parties quickly and reliably.")]),e._v(" "),i("li",[e._v("Consensus — Achieving agreement among multiple processes.\n"),i("ul",[i("li",[e._v("two generals' problem — always one "),i("code",[e._v("ACK")]),e._v(" away from reaching a consensus")]),e._v(" "),i("li",[e._v("FLP impossibility — if we do not consider an upper time bound for the process to complete the algorithm steps, process failures can’t be reliably detected, and there’s no deterministic algorithm to reach a consensus\n"),i("ul",[i("li",[e._v("synchrony assumption — there is an upper time bound in time difference between the two process-local time sources")])])])])])])]),e._v(" "),i("li",[i("p",[e._v("links")]),e._v(" "),i("ul",[i("li",[e._v("fair-loss link\n"),i("ul",[i("li",[e._v("fair loss — if both sender and recipient are correct and the sender keeps retransmitting the message infinitely many times, it will eventually be delivered")]),e._v(" "),i("li",[e._v("finite duplication — sent messages will not be delivered infinitely many times")]),e._v(" "),i("li",[e._v("no creation — a link will not create messages never sent")])])]),e._v(" "),i("li",[e._v("stubborn link — sender keeps retransmitting until acknowledgement")]),e._v(" "),i("li",[e._v("perfect link\n"),i("ul",[i("li",[e._v("reliable delivery — every message sent once by the correct process A to the correct process B, will eventually be delivered")]),e._v(" "),i("li",[e._v("no duplication")]),e._v(" "),i("li",[e._v("no creation")])])])])]),e._v(" "),i("li",[i("p",[e._v("fallacies of distributed systems")]),e._v(" "),i("ul",[i("li",[e._v("processing — not instantaneous")]),e._v(" "),i("li",[e._v("clock and time — time drift")]),e._v(" "),i("li",[e._v("state consistency")]),e._v(" "),i("li",[e._v("remote execution latency and other problems")]),e._v(" "),i("li",[e._v("network partition and partial failures\n"),i("ul",[i("li",[e._v("network partition — two or more servers cannot communicate with each other")]),e._v(" "),i("li",[e._v("partial failures — a part of a system is unavailable or functioning incorrectly")])])]),e._v(" "),i("li",[e._v("cascading failures — a failed node increase load on other nodes; recovery exhausting network resources; corruption that can propagate through standard delivery mechanisms\n"),i("ul",[i("li",[e._v("alleviate — planning and coordinating execution (load balance), circuit breakers, jittered exponential backoff, checksumming and validation")])])])])])]),e._v(" "),i("h2",{attrs:{id:"failure-detection"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#failure-detection"}},[e._v("#")]),e._v(" Failure Detection")]),e._v(" "),i("ol",[i("li",[i("p",[e._v("failure models")]),e._v(" "),i("ul",[i("li",[e._v("crash fault\n"),i("ul",[i("li",[e._v("crash-stop — processes crash and stay in the state; the model means that the algorithm does not rely on recovery for correctness or liveness; nothing prevents processes from recover‐ ing, catching up with the system state, and participating in the next instance of the algorithm")]),e._v(" "),i("li",[e._v("crash-recovery — recoverable, durable state and continued execution attempts")])])]),e._v(" "),i("li",[e._v("omission fault — the algorithm that was supposed to execute certain steps either skips them or the results of this execution are not visible\n"),i("ul",[i("li",[e._v("example — the process skips some of the algorithm steps, or is not able to execute them, or this execution is not visible to other participants, or it cannot send or receive messages to and from other participants")])])]),e._v(" "),i("li",[e._v("arbitrary fault or Byzantine fault — out of control and supplying incorrect values\n"),i("ul",[i("li",[e._v("origin — spies in the Byzantine army deliver false messages deliberately")]),e._v(" "),i("li",[e._v("example — a process in a consensus algorithm decides on a value that no other participant has ever proposed; can happen due to bugs in software, or due to processes running different versions")])])])])]),e._v(" "),i("li",[i("p",[e._v("testing and failure handle")]),e._v(" "),i("ul",[i("li",[e._v("testing — create partitions, simulate bit rot, increase latencies, diverge clocks, and magnify relative processing speeds")]),e._v(" "),i("li",[e._v("handle\n"),i("ul",[i("li",[e._v("mask failures — forming process groups and introducing redundancy into the algorithm")])])])])]),e._v(" "),i("li",[i("p",[e._v("failure detection")]),e._v(" "),i("ul",[i("li",[e._v("failure detector — a local subsystem responsible for identifying failed or unreachable processes to exclude them from the algorithm and guarantee "),i("em",[e._v("liveness")]),e._v(" while preserving "),i("em",[e._v("safety")]),e._v(" "),i("ul",[i("li",[e._v("liveness — guarantees that a specific intended event must occur. For example, if one of the processes has failed, a failure detector must detect that failure")]),e._v(" "),i("li",[e._v("safety — unintended events will not occur. For example, if a failure detector has marked a process as dead, this process had to be, in fact, dead")])])]),e._v(" "),i("li",[e._v("failure-detection algorithm essential properties\n"),i("ul",[i("li",[e._v("completeness — every non-faulty member should eventually notice the process failure, and the algorithm should be able to make progress and eventually reach its final result")]),e._v(" "),i("li",[e._v("tradeoff — efficiency - accuracy")])])]),e._v(" "),i("li",[e._v("failure detection: heartbeats and pings\n"),i("ul",[i("li",[e._v("deadline failure detector — uses heartbeats and reports a process failure if it has failed to register within a fixed time interval\n"),i("ul",[i("li",[e._v("problem — ping frequency and timeout, and interprocess connectivity")])])]),e._v(" "),i("li",[e._v("timeout-free failure detector: heartbeat with counter — send heartbeats with their travel path, "),i("a",{attrs:{href:"https://ecommons.cornell.edu/bitstream/1813/7286/1/97-1631.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("tbd"),i("OutboundLink")],1)]),e._v(" "),i("li",[e._v("outsourced heartbeats — if no response for a ping, demand other randomly selected nodes to ping and forward ACK back")]),e._v(" "),i("li",[e._v("phi-accrual (φ-accrual) failure detector — a probability instead of a binary state\n"),i("ul",[i("li",[e._v("suspicion level φ — computed by comparing the actual heartbeat arrival time, with the approximated arrival time sampled by a sliding window of arrival times of the most recent heartbeats")]),e._v(" "),i("li",[e._v("dynamic — dynamically adapts to changing network conditions by adjusting the scale on which the node can be marked as a suspect")])])])])]),e._v(" "),i("li",[e._v("other failure detection\n"),i("ul",[i("li",[e._v("gossip-style failure detection — each member maintains a list of other members, their heartbeat counters and last updated timestamps. Periodically, each member increments its heartbeat counter and distributes its "),i("strong",[e._v("list")]),e._v(" to a random neighbor. Nodes also periodically check the list of states and heartbeat counters. If any node did not update its counter for long enough, it is considered failed (or unreachable).")]),e._v(" "),i("li",[e._v("FUSE (failure notification service) — processes divided into groups, processes within one group periodically ping others and in case of ping failure itself will stop respond to ping; for reliable and cheap failure propagation")])])])])])]),e._v(" "),i("h2",{attrs:{id:"leader-election"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#leader-election"}},[e._v("#")]),e._v(" Leader Election")]),e._v(" "),i("ol",[i("li",[i("p",[e._v("election algorithms")]),e._v(" "),i("ul",[i("li",[e._v("properties\n"),i("ul",[i("li",[e._v("liveness — most of the time there will be a leader, and the election will eventually complete")]),e._v(" "),i("li",[e._v("safety — at most one leader at a time, and completely eliminate the possibility of a split brain situation\n"),i("ul",[i("li",[e._v("in practice, not met by many leader election algorithms")]),e._v(" "),i("li",[e._v("split brain — when two or more leaders serving the same purpose are elected but unaware of each other")]),e._v(" "),i("li",[e._v("possible split brain solution — cluster-wide majority of votes requirement; third party coordinator")])])])])]),e._v(" "),i("li",[e._v("difference with distributed locks — other processes do not need to know who holds the lock, but not so for the leader role")]),e._v(" "),i("li",[e._v("determine leader status for reelection — failure detection algorithms")])])]),e._v(" "),i("li",[i("p",[e._v("bully algorithm, monarchial leader election — each process preassigned a unique rank, the highest one wins election")]),e._v(" "),i("ul",[i("li",[e._v("steps — the process send election message to the higher ranked, notify the highest that responded or itself if no higher is up, then the highest notify all lower-ranked processes about the new leader")]),e._v(" "),i("li",[e._v("drawback\n"),i("ul",[i("li",[e._v("prone to split brain in the presence of network partitions")]),e._v(" "),i("li",[e._v("hot spots")])])]),e._v(" "),i("li",[e._v("optimization variants\n"),i("ul",[i("li",[e._v("next-in-line failover — when one of the processes detects a leader failure, it will send a message to the highest-ranked alternative from the failover list provided by the failed leader one by one; if one is able to ACK, it becomes a new leader and broadcasts the leadership")]),e._v(" "),i("li",[e._v("candidate/ordinary optimization — spilt nodes into two subsets, candidate and ordinary, the ordinary node send election message to candidate nodes, and broadcasts the new leader which is the highest ranked among ACKs\n"),i("ul",[i("li",[e._v("mitigate multiple simultaneous elections — tiebreaker variable δ, a process-specific delay before initiate the election")])])])])])])]),e._v(" "),i("li",[i("p",[e._v("invitation algorithm — allow multiple leaders by definition. Each process starts as a leader of a new group, inviting other leaders to join, when non-leader nodes are invited, respond with own leaders. Leaders broadcasts the new leader to its own group when joining another group, effectively merge two groups")]),e._v(" "),i("ul",[i("li",[e._v("new leader when merging — choose the one in the larger group, keep the number of messages required to merge groups to a minimum")])])]),e._v(" "),i("li",[i("p",[e._v("ring algorithm — all nodes in the system form a ring. A node starts election by forwarding live node set to its successor, successor's successor and so on until reachable. Itself appended to the live node set before forwarding. When the message comes back to the initial node, the highest-ranked node from the live set is chosen as a leader")]),e._v(" "),i("ul",[i("li",[e._v("see also — timeout-free failure detector")]),e._v(" "),i("li",[e._v("variant — only keep the highest ranked in the live set")])])])]),e._v(" "),i("h2",{attrs:{id:"replication-consistency"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#replication-consistency"}},[e._v("#")]),e._v(" Replication Consistency")]),e._v(" "),i("ol",[i("li",[i("p",[e._v("CAP conjuncture — CP or AP for choice")]),e._v(" "),i("ul",[i("li",[e._v("consistency — atomic or linearizable (serializable) consistency")]),e._v(" "),i("li",[e._v("availability — the ability of the system to serve a response for every request successfully\n"),i("ul",[i("li",[e._v("by redundancy and replication, which bring sync and recovery problem")])])]),e._v(" "),i("li",[e._v("partition tolerance")]),e._v(" "),i("li",[e._v("PACELC, CAP extension — in presence of P, choose between A and C; else (E), even if the system is running normally, choose between latency (L) and consistency (C)")]),e._v(" "),i("li",[e._v("harvest and yield — relaxed A and C, shifts the focus of the trade-off from the absolute to the relative terms\n"),i("ul",[i("li",[e._v("harvest — how complete (consistent) the query is")]),e._v(" "),i("li",[e._v("yield — request success rate, number of successfully completed requests compared to the total number of attempted requests")])])])])]),e._v(" "),i("li",[i("p",[e._v("consistency model")]),e._v(" "),i("ul",[i("li",[e._v("strict consistency — ideal")]),e._v(" "),i("li",[e._v("linearizable (serializable) — effects of the write become visible to all readers exactly once at linearization point in time between its start and end")]),e._v(" "),i("li",[e._v("sequential consistency — happen-before for the same-origin writes; cross-origin writes can be arbitrary order, but observed in the same order by readers")]),e._v(" "),i("li",[e._v("causal consistency — all processes have to see causally related operations in the same order; logically timestamped, dependencies (causal before operations or values) tracked")]),e._v(" "),i("li",[e._v("examples\n"),i("ul",[i("li",[e._v("Reusable Infrastructure for Linearizability (RIFL), a linearizable RPC mechanism by guaranteeing that the RPC cannot be executed more than once\n"),i("ul",[i("li",[e._v("messages — uniquely identified with the client ID and a client-local monotonically increasing sequence number")]),e._v(" "),i("li",[e._v("client ID — use lease, unique identifiers that expire after some time, have to be renewed periodically")]),e._v(" "),i("li",[e._v("retry — return a associated completion object to the client if already executed")]),e._v(" "),i("li",[e._v("completion object — associated with a operation, persisted along with the actual data records, removed when no more retry promised or crash detected (by lease expiration) on the client")])])]),e._v(" "),i("li",[e._v("vector clock, detect causal conflicts — used by Dynamo; processes maintain vectors of logical clocks, with one clock per process; clocks starts at the initial value, is incremented upon a new event, and maximized upon receiving clock vectors from other processes (which is also an event)\n"),i("ul",[i("li",[e._v("Lamport timestamp — a single value instead of a vector, vector clock is its improvement")]),e._v(" "),i("li",[e._v("solve conflicts\n"),i("ul",[i("li",[e._v("last-write-wins rule")]),e._v(" "),i("li",[e._v("ask users — store causal history, add garbage collection, and ask the user to reconcile divergent histories")])])])])])])])])]),e._v(" "),i("li",[i("p",[e._v("session models, aka. client-centric consistency models, not mutual exclusive")]),e._v(" "),i("ul",[i("li",[e._v("read-own-writes consistency model — every write issued by the client is visible to it")]),e._v(" "),i("li",[e._v("monotonic reads model — values read by the client should be at least as recent as last read ones")]),e._v(" "),i("li",[e._v("monotonic writes model — effects by a client have to become visible in the same order to all other processes; otherwise, old data can be “resurrected”")]),e._v(" "),i("li",[e._v("writes-follow-reads, aka. session causality — writes are ordered after writes that were observed by previous read operations")]),e._v(" "),i("li",[e._v("example\n"),i("ul",[i("li",[e._v("Pipelined RAM (PRAM) consistency, aka. FIFO consistency — monotonic reads, monotonic writes, and read-own-writes combined; unlike under sequential consistency, writes from different processes can be observed in different order")])])])])]),e._v(" "),i("li",[i("p",[e._v("tunable consistency — When performing a write, the coordinator should submit it to N nodes, but can wait for only W nodes before it proceeds (or W - 1 in case the coordinator is also a replica). Similarly, when performing a read, the coordinator has to collect at least R responses")]),e._v(" "),i("ul",[i("li",[e._v("replication factor N")]),e._v(" "),i("li",[e._v("write consistency W")]),e._v(" "),i("li",[e._v("read consistency R")]),e._v(" "),i("li",[e._v("trade off — increase W, R increases latencies and require more node availability; decreasing them improves system availability while sacrificing consistency")]),e._v(" "),i("li",[e._v("example\n"),i("ul",[i("li",[e._v("consistent write-heavy systems — may sometimes pick W = 1 and R = N; W = N and R = 1 achieves the same")])])])])]),e._v(" "),i("li",[i("p",[e._v("quorum — a consistency level that consists of ⌊N/2⌋ + 1 nodes")]),e._v(" "),i("ul",[i("li",[e._v("other definitions\n"),i("ul",[i("li",[e._v("the minimum number of votes required")]),e._v(" "),i("li",[e._v("the constraint R + W > N")])])]),e._v(" "),i("li",[e._v("constraints\n"),i("ul",[i("li",[e._v("R + W > N — the system can guarantee returning the most recent written value")]),e._v(" "),i("li",[e._v("W > N/2 — cannot write concurrently on the same data item")])])]),e._v(" "),i("li",[e._v("does not guarantee monotonicity alone — in cases of incomplete writes, use blocking read-repair")]),e._v(" "),i("li",[e._v("witness replica — witness replicas merely store the record indicating the fact that the write operation occurred, for improving storage costs, used in Cassandra\n"),i("ul",[i("li",[e._v("copy replica, witness replica")]),e._v(" "),i("li",[e._v("upgrade — in cases of write timeouts or copy replica failures, witness replicas can be upgraded to copy replicas")]),e._v(" "),i("li",[e._v("requirement for availability — n copy and m witness replicas has same availability guarantees as n + m copies, if W and R above majority and at least one replica is a copy replica in a quorum")])])]),e._v(" "),i("li",[e._v("sloppy quorum — in case of replica failures, write operations can use additional healthy nodes from the node list for hinted handoff")])])]),e._v(" "),i("li",[i("p",[e._v("eventual consistency")]),e._v(" "),i("ul",[i("li",[e._v("BASE\n"),i("ul",[i("li",[e._v("basically available")]),e._v(" "),i("li",[e._v("soft state")]),e._v(" "),i("li",[e._v("eventual consistency — if there are no additional updates performed against the data item, eventually all accesses return the latest written value")])])]),e._v(" "),i("li",[e._v("strong eventual consistency — operations to preserve additional state that allows the diverged states to be reconciled\n"),i("ul",[i("li",[e._v("example: Conflict-Free Replicated Data Types (CRDTs), used in Redis — specialized data structures that preclude the existence of conflict and allow operations on these data types to be applied in any order without changing the result\n"),i("ul",[i("li",[e._v("Commutative Replicated Data Types (CmRDTs) — tbd")]),e._v(" "),i("li",[e._v("unordered grow-only set (G-Set) — to reconstruct the current state of the set, all elements contained in the removal set are subtracted from the addition set")])])])])])])]),e._v(" "),i("li",[i("p",[e._v("other consistency")]),e._v(" "),i("ul",[i("li",[e._v("convergent consistency — see gossip")]),e._v(" "),i("li",[e._v("external consistency — see Spanner")])])])]),e._v(" "),i("h2",{attrs:{id:"dissemination"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#dissemination"}},[e._v("#")]),e._v(" Dissemination")]),e._v(" "),i("ol",[i("li",[e._v("Dissemination\n"),i("ul",[i("li",[e._v("usage example — quick and reliable propagation may be less applicable to data records and more important for the cluster-wide metadata")]),e._v(" "),i("li",[e._v("ways\n"),i("ul",[i("li",[e._v("broadcast")]),e._v(" "),i("li",[e._v("anti-entropy — periodic peer-to-peer information exchange")]),e._v(" "),i("li",[e._v("gossip — message recipients become broadcasters and help to spread the information quicker and more reliably")])])])])])]),e._v(" "),i("h3",{attrs:{id:"anti-entropy"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#anti-entropy"}},[e._v("#")]),e._v(" Anti-Entropy")]),e._v(" "),i("ol",[i("li",[i("p",[e._v("anti-entropy — compares and reconciles missing or conflicting records; used to bring the nodes back up-to-date in case the primary delivery mechanism has failed")]),e._v(" "),i("ul",[i("li",[e._v("foreground anti-entropy — piggyback read or write requests: hinted handoff, read repairs, etc.")]),e._v(" "),i("li",[e._v("background anti-entropy — auxiliary structures such as Merkle trees and update logs\n"),i("ul",[i("li",[e._v("Merkle trees — a compact hashed representation of the local data, building a tree of hashes; calculated recursively from the bottom to the top, a change in data triggers recomputation of the entire subtree; trade-off between the size of a tree and its precision")]),e._v(" "),i("li",[e._v("bitmap version vectors — resolve data conflicts based on recency: each node keeps a per-peer log of operations that have occurred locally or were replicated. Dur‐ ing anti-entropy, logs are compared, and missing data is replicated to the target node; tbd")])])])])]),e._v(" "),i("li",[i("p",[e._v("read repair — repair when reading: replicas send different responses, the coordinator sends missing updates to the replicas where they’re missing")]),e._v(" "),i("ul",[i("li",[e._v("asynchronous read repair")]),e._v(" "),i("li",[e._v("blocking read repair — ensures read monotonicity for quorum reads\n"),i("ul",[i("li",[e._v("not every request needs to block — because of the read monotonicity of blocking repairs, we can also expect subsequent requests to return the same consistent results, as long as there was no write operation that has completed in the interim")])])]),e._v(" "),i("li",[e._v("example: Cassandra — use specialized iterators with merge listeners, which reconstruct differences between the merged result and individual inputs. Its output is then used by the coordinator to notify replicas about the missing data")])])]),e._v(" "),i("li",[i("p",[e._v("digest read — the coordinator compare the digest of replicas before issue full reads")])]),e._v(" "),i("li",[i("p",[e._v("hinted handoff, a write-side repair mechanism — if the target node fails to acknowledge the write, the write coordinator or one of the replicas stores a special record, called a hint, which is replayed to the target node as soon as it comes back up")])])]),e._v(" "),i("h3",{attrs:{id:"gossip"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#gossip"}},[e._v("#")]),e._v(" Gossip")]),e._v(" "),i("p",[e._v("Gossip — the reach of a broadcast and the reliability of anti-entropy")]),e._v(" "),i("ol",[i("li",[i("p",[e._v("gossip model — modeled like rumors or epidemics")]),e._v(" "),i("ul",[i("li",[i("a",{attrs:{href:"https://en.wikipedia.org/wiki/Compartmental_models_in_epidemiology#The_SIR_model",target:"_blank",rel:"noopener noreferrer"}},[e._v("SIR model"),i("OutboundLink")],1),e._v(" "),i("ul",[i("li",[e._v("infectious — a process that holds a record that has to be spread around")]),e._v(" "),i("li",[e._v("susceptible — processes have not received the update yet")]),e._v(" "),i("li",[e._v("removed (recovered) — processes not willing to propagate the new state after a period of active dissemination")])])]),e._v(" "),i("li",[e._v("consistency model: convergent consistency — nodes have a higher probability to have the same view of the events that occurred further in the past")])])]),e._v(" "),i("li",[i("p",[e._v("gossip parameters")]),e._v(" "),i("ul",[i("li",[e._v("fanout "),i("code",[e._v("f")]),e._v(" — periodically select "),i("code",[e._v("f")]),e._v(" peers at random and exchange currently “hot” information with them")]),e._v(" "),i("li",[e._v("message redundancy — the overhead incurred by repeated delivery")]),e._v(" "),i("li",[e._v("latency — the amount of time the system requires to reach convergence (note that when all peers notified, gossip can still last)")]),e._v(" "),i("li",[e._v("point of interest lost\n"),i("ul",[i("li",[e._v("probabilistically — the probability of propagation stop is computed for each process on every step")]),e._v(" "),i("li",[e._v("threshold — the number of received duplicates is counted, and propagation is stopped when this number is too high")])])])])]),e._v(" "),i("li",[i("p",[e._v("overlay network — a temporary fixed topology in a gossip system, middle ground for randomness and non-probabilistic")]),e._v(" "),i("ul",[i("li",[e._v("fix nodes to spread — nodes can sample their peers and select the best contact points based on proximity (usually measured by the latency)\n"),i("ul",[i("li",[e._v("island problem")])])]),e._v(" "),i("li",[e._v("tradeoff — randomness for robustness and redundancy, non-probabilistic for less redundancy and more optimal route")])])]),e._v(" "),i("li",[i("p",[e._v("partial view")]),e._v(" "),i("ul",[i("li",[e._v("problem with full view — maintaining a full view of the cluster can get expensive and impractical, especially if the churn is high\n"),i("ul",[i("li",[e._v("churn — measure of the number of joining and leaving nodes in the system")])])]),e._v(" "),i("li",[e._v("peer sampling service — maintains a partial view of the cluster, which is periodically refreshed using gossip")])])]),e._v(" "),i("li",[i("p",[e._v("hybrid gossip — fixed topologies when the system is in a stable state, fall back to gossip for failover and system recovery")]),e._v(" "),i("ul",[i("li",[e._v("push/lazy-push multicast trees (plumtrees)\n"),i("ul",[i("li",[e._v("overlay under normal conditions — each send full messages to just a small subset of peers provided by the peer sampling service, forming a spanning tree")]),e._v(" "),i("li",[e._v("lazy-push — each node sends the full message to the small subset of nodes, and for the rest of the nodes, it "),i("strong",[e._v("lazily")]),e._v(" forwards only the message ID for the recipient to query back if the ID not seen yet, effectively fall back to gossip in case of failure and can repair the overlay simultaneously")])])]),e._v(" "),i("li",[e._v("hybrid partial view (HyParView) protocol — each node maintains a small active view and a larger passive view of the cluster, for overlay and active view backup respectively, tbd")])])])]),e._v(" "),i("h2",{attrs:{id:"distributed-transactions"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#distributed-transactions"}},[e._v("#")]),e._v(" Distributed Transactions")]),e._v(" "),i("ol",[i("li",[i("p",[e._v("2PC, two phase commit — used in XA, transaction manager as the coordinator")]),e._v(" "),i("ul",[i("li",[e._v("recovery — to accommodate recovery from failure (automatic in most cases) the protocol's participants use logging of the protocol's states, during each step the coordinator and cohorts have to write the results of each operation to durable storage to be able to reconstruct the state")]),e._v(" "),i("li",[e._v("coordinator failure\n"),i("ul",[i("li",[e._v("one of the cohorts does not receive from the coordinator at 2nd phase — information about the decision can be replicated from the peers’ transaction logs or from the backup coordinator")]),e._v(" "),i("li",[e._v("blocking — if vote collected but failed to broadcast decision, cohorts remain in an undecided state, until coordinator recover or restart anew with a backup")])])]),e._v(" "),i("li",[e._v("variant: Spanner — perform 2PC over Paxos groups per partition rather than individual nodes to improve protocol availability; within the Paxos group, 2PC contacts only the node that serves as a leader\n"),i("ul",[i("li",[e._v("TrueTime — a high-precision wall-clock API that also exposes an uncertainty bound, allowing local operations to introduce artificial slowdowns to wait for the uncertainty bound to pass")]),e._v(" "),i("li",[e._v("operations\n"),i("ul",[i("li",[e._v("read-write transactions — require locks, pessimistic concurrency control, and presence of the leader replica")]),e._v(" "),i("li",[e._v("read-only transactions — lock-free and can be executed at any replica")]),e._v(" "),i("li",[e._v("snapshot reads\n"),i("ul",[i("li",[e._v("multi-version — multiple timestamped versions of the record can be stored")])])])])]),e._v(" "),i("li",[e._v("Paxos group leader — every write has to go through the leader, which holds a lock table that is used to implement concurrency control using the two-phase locking")]),e._v(" "),i("li",[e._v("external consistency — transaction timestamps reflect serialization order, even in cases of distributed transactions")]),e._v(" "),i("li",[e._v("tbd")])])]),e._v(" "),i("li",[e._v("variant: Percolator\n"),i("ul",[i("li",[e._v("snapshot isolation (SI) — "),i("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/54979396",target:"_blank",rel:"noopener noreferrer"}},[e._v("zhihu"),i("OutboundLink")],1)]),e._v(" "),i("li",[e._v("timestamp oracle — a source of clusterwide-consistent monotonically increasing timestamps")]),e._v(" "),i("li",[e._v("tbd")])])])])]),e._v(" "),i("li",[i("p",[e._v("3PC — adds an extra step, and timeouts on both sides, to solve blocking of 2PC")]),e._v(" "),i("ul",[i("li",[e._v("add prepare between propose and commit — if vote passed, the coordinator sends a Prepare message, instructing participants to be prepared, and then participants ACK")]),e._v(" "),i("li",[e._v("add timeout\n"),i("ul",[i("li",[e._v("timeout for prepare — cohorts may abort the transaction after timeout for Prepare command, solving the blocking problem of 2PC")]),e._v(" "),i("li",[e._v("timeout after prepared — commit even if no commit command from coordinator in phase 3")])])]),e._v(" "),i("li",[e._v("split brain — network partition at the 2nd phase, making some nodes prepared while others not")])])]),e._v(" "),i("li",[i("p",[e._v("Calvin — let replicas agree on the execution order, tbd")]),e._v(" "),i("ul",[i("li",[e._v("sequencer — an entry point for transactions, the timeline is split into epochs so transactions batched")])])]),e._v(" "),i("li",[i("p",[e._v("coordination avoidance — I-Confluent operations can be executed without additional coordination")]),e._v(" "),i("ul",[i("li",[e._v("Invariant Confluence (I-Confluence) — a property that ensures two invariant-valid but diverged database states can be merged into a single valid, final state\n"),i("ul",[i("li",[e._v("invariant — invariants in this case preserve consistency in ACID terms")])])]),e._v(" "),i("li",[e._v("merge function — required for bringing diverged states back to convergence")]),e._v(" "),i("li",[e._v("required properties for coordination avoidance\n"),i("ul",[i("li",[e._v("global validity — required invariants are always satisfied, for both merged and divergent commit‐ ted database states, and transactions cannot observe invalid states")]),e._v(" "),i("li",[e._v("availability — if all nodes holding states are reachable by the client, the transaction has to reach a decision")]),e._v(" "),i("li",[e._v("convergence — nodes are able to reach the same states if no further transactions and indefinite network partitions")]),e._v(" "),i("li",[e._v("coordination freedom — local transaction execution is independent from other nodes")])])]),e._v(" "),i("li",[e._v("example\n"),i("ul",[i("li",[e._v("Read-Atomic Multi Partition (RAMP) — 2PC but attempt to reduce the amount of coordination by using invariants to determine where coordination can be avoided, and only paying the full price if it’s absolutely necessary, tbd")])])])])]),e._v(" "),i("li",[i("p",[e._v("事务补偿机制 — command design pattern with undo operation, the invoker sorts and executes all concerned commands in order; if no dependency, concurrent execution is possible")])])]),e._v(" "),i("h2",{attrs:{id:"consensus"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#consensus"}},[e._v("#")]),e._v(" Consensus")]),e._v(" "),i("ol",[i("li",[i("p",[e._v("consensus properties")]),e._v(" "),i("ul",[i("li",[e._v("agreement — the decision value is the same for all correct processes")]),e._v(" "),i("li",[e._v("validity — the decided value was proposed by one of the processes")]),e._v(" "),i("li",[e._v("termination — all correct processes eventually reach the decision")])])]),e._v(" "),i("li",[i("p",[e._v("broadcast — see dissemination")]),e._v(" "),i("ul",[i("li",[e._v("best effort broadcast — fail silently, do not try to rebroadcast the message")]),e._v(" "),i("li",[e._v("reliable broadcast\n"),i("ul",[i("li",[e._v("native approach: flooding algorithm — if sender crash detected, processes forward it to every other process it is aware of; n^2 messages and out of order")]),e._v(" "),i("li",[e._v("atomic broadcast — see below")])])])])]),e._v(" "),i("li",[i("p",[e._v("atomic broadcast, aka. the total order multicast — guarantees both reliable delivery and total order")]),e._v(" "),i("ul",[i("li",[e._v("properties\n"),i("ul",[i("li",[e._v("atomicity — either all non-failed processes deliver the message, or none do")]),e._v(" "),i("li",[e._v("order — all non-failed processes deliver the messages in the same order")])])]),e._v(" "),i("li",[e._v("examples\n"),i("ul",[i("li",[e._v("virtual synchrony — use group view as broadcast barrier, message delivery only when message receipt for all the group members, and use a single process (sequencer) for message order, rarely used\n"),i("ul",[i("li",[e._v("group view — the presentation of current active nodes in a group")])])]),e._v(" "),i("li",[e._v("ZAB, ZooKeeper atomic broadcast — tbd\n"),i("ul",[i("li",[e._v("leader and follower — followers forward requests to the leader, the leader turn requests into proposals and broadcast to all followers")]),e._v(" "),i("li",[e._v("zxid — 64 bit proposal ID, higher 32 bit for epoch\n"),i("ul",[i("li",[e._v("epochs — logical clock; during any epoch, there can be only one leader")])])]),e._v(" "),i("li",[e._v("protocol steps, executed by the prospective leader\n"),i("ol",[i("li",[e._v("leader election — choose prospective leader, by any reasonable election algorithm (safety is guaranteed by the further algorithm steps)")]),e._v(" "),i("li",[e._v("discovery — the prospective leader learns about the latest epoch known by every other process, and propose a new epoch greater than the latest back to the followers, who then respond with the latest zxid seen in the previous epoch and update own acceptedEpoch")]),e._v(" "),i("li",[e._v("synchronization — the prospective leader sync with followers (according to collected zxid) for recovery and to ensure consistency, if a quorum successfully synced, the leader is established")]),e._v(" "),i("li",[e._v("broadcast — active messaging starts, 2PC like: the leader receives client messages, establishes their order, and broadcasts them to the followers: it sends a new proposal, waits for a quorum of followers to respond with acknowledgments and, finally, commits it")])])])])])])])])]),e._v(" "),i("li",[i("p",[e._v("Raft")]),e._v(" "),i("ul",[i("li",[e._v("roles\n"),i("ul",[i("li",[e._v("candidate — attempt to collect a quorum of votes to become a leader")]),e._v(" "),i("li",[e._v("leader — handle client requests and interacts with a replicated state machine, for a certain period called term, aka. epoch, which a logical clock")]),e._v(" "),i("li",[e._v("follower — persist log entries and respond to requests from the leader and candidates, also forward requests to the leader")])])]),e._v(" "),i("li",[e._v("components\n"),i("ul",[i("li",[e._v("leader election — if no heartbeat from leader for some time (election timeout), a follow becomes a candidate, term increments and requests votes from other nodes, the request includes the new term and the newest log entry; each node can vote at most one candidate and the candidate becomes leader if a quorum (majority) collected, or the candidate becomes a follower if heartbeat with a term not smaller than current term from a new leader received; restart if not enough vote till timeout, term also incremented for when next election started\n"),i("ul",[i("li",[e._v("stale candidates not qualified — if the follower’s log information is more up-to-date, the follow will deny to vote for this candidate")])])]),e._v(" "),i("li",[e._v("periodic heartbeat — the leader periodically sends heartbeats to all followers to maintain its term")]),e._v(" "),i("li",[e._v("log replication / broadcast — the leader can repeatedly append new values to the replicated log and broadcast them; an entry is considered committed if a quorum of ACK and commit decision also replicated\n"),i("ul",[i("li",[e._v("order keeping — a follower (require reconciliation or) rejects a higher-numbered entry if the ID and term of the entry that immediately precedes it, sent by the leader, do not match the highest entry according to its own records")])])])])]),e._v(" "),i("li",[e._v("failure scenarios\n"),i("ul",[i("li",[e._v("competing candidates — jittered timeout")]),e._v(" "),i("li",[e._v("follower failure — retry of the leader, can be batched")]),e._v(" "),i("li",[e._v("restore state when new leadership — by finding a common ground (the highest log entry on which both the leader and follower agree), and ordering followers to discard all (uncommitted) entries appended after this point, and then sends the most recent entries from its log")])])])])]),e._v(" "),i("li",[i("p",[e._v("Byzantine consensus")]),e._v(" "),i("ul",[i("li",[e._v("cross-validate — have to verify other nodes’ behaviors by comparing returned results with the majority responses, so most Byzantine consensus algorithms require N^2 messages to complete an algorithm step, where N is the size of the quorum")]),e._v(" "),i("li",[e._v("Practical Byzantine Fault Tolerance (PBFT) — tbd")])])])]),e._v(" "),i("h3",{attrs:{id:"paxos"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#paxos"}},[e._v("#")]),e._v(" Paxos")]),e._v(" "),i("ol",[i("li",[i("p",[e._v("Paxos")]),e._v(" "),i("ul",[i("li",[e._v("participants\n"),i("ul",[i("li",[e._v("proposers — receive client requests, create proposals and receive votes\n"),i("ul",[i("li",[e._v("proposal IDs — proposer distinct, e.g. global ID generator, e.g. slotted timestamp, e.g. 1, 3, 5... for proposer 1 and 2, 4, 6... for proposer 2")])])]),e._v(" "),i("li",[e._v("acceptors — vote to accept or reject proposals")]),e._v(" "),i("li",[e._v("learners — replicas, storing the outcomes of the accepted proposals")])])]),e._v(" "),i("li",[e._v("colocate — a single process can simultaneously be a proposer, an acceptor, and a learner")]),e._v(" "),i("li",[e._v("two phases\n"),i("ul",[i("li",[e._v("propose\n"),i("ul",[i("li",[e._v("proposers send a "),i("code",[e._v("Prepare(n)")]),e._v(" message with proposal ID "),i("code",[e._v("n")]),e._v(" to acceptors, possible to retry with a higher ID if got ignored and timeout")]),e._v(" "),i("li",[e._v("acceptor check if it promised to ignore, if not, reply with "),i("code",[e._v("Promise(n)")]),e._v(", promising to ignore ID lower than "),i("code",[e._v("n")]),e._v(", along with accepted ID and value "),i("code",[e._v("Promise(m, v)")]),e._v(" if already accepted, piggybacking the value")])])]),e._v(" "),i("li",[e._v("replication — after collecting a quorum of votes, the proposer can start the replication\n"),i("ul",[i("li",[e._v("proposer commits the proposal by sending acceptors an "),i("code",[e._v("Accept!(n, v)")]),e._v(", where "),i("code",[e._v("v")]),e._v(" is from "),i("code",[e._v("Promise(m, v)")]),e._v(" where "),i("code",[e._v("m")]),e._v(" is the highest or a self-picked value if no "),i("code",[e._v("Promise(m, n)")]),e._v(" received")]),e._v(" "),i("li",[e._v("acceptor check if it promised to ignore, if not, reply with "),i("code",[e._v("Accept(n, v)")]),e._v(", also send it to all learners")]),e._v(" "),i("li",[e._v("if proposer/learner get majority of "),i("code",[e._v("Accept(n, v)")]),e._v(", they know consensus reached on "),i("code",[e._v("v")])])])])])]),e._v(" "),i("li",[e._v("failure scenarios\n"),i("ul",[i("li",[e._v("two or more proposers competing and overwrite the quorum of each other\n"),i("ul",[i("li",[e._v("avoid hot spots and contention — jittered exponential backoff")])])]),e._v(" "),i("li",[e._v("proposer fail after at least one accept — if the client is connected only to the original proposer, the client might not know about the result of the Paxos round execution\n"),i("ul",[i("li",[e._v("value piggybacked and consensus reached")]),e._v(" "),i("li",[e._v("value not piggybacked and consensus on a new value reached\n"),i("ul",[i("li",[e._v("if no overlap of acceptors between the quorum of another proposer")]),e._v(" "),i("li",[e._v("or if the accepted acceptors fail")])])])])])])])])]),e._v(" "),i("li",[i("p",[e._v("multi-Paxos — aka. replicated log, avoid repeating the propose phase using leader with lease")]),e._v(" "),i("ul",[i("li",[e._v("problem with vanilla Paxos — reads can be implemented by running a Paxos round that would collect any values from incomplete rounds")]),e._v(" "),i("li",[e._v("leader — a distinguished proposer, allows reads from the active leader without collecting a quorum")]),e._v(" "),i("li",[e._v("lease — participants will not accept proposals from other leaders for the period of the lease; the leader periodically contacts the participants, notifying them that it is still alive, effectively prolonging its lease\n"),i("ul",[i("li",[e._v("rely on the bounded clock synchrony between the participants")])])])])]),e._v(" "),i("li",[i("p",[e._v("fast Paxos — reduce the number of round-trips by one, tbd")]),e._v(" "),i("ul",[i("li",[e._v("participants besides those in vanilla Paxos\n"),i("ul",[i("li",[e._v("coordinator — the proposer that has collected a sufficient number of responses during the propose phase")]),e._v(" "),i("li",[e._v("acceptor size — 3f + 1, where f is the number of processes allowed to fail")]),e._v(" "),i("li",[e._v("quorum size — 2f + 1")])])]),e._v(" "),i("li",[e._v("mode\n"),i("ul",[i("li",[e._v("classic — as vanilla Paxos")]),e._v(" "),i("li",[e._v("fast — if the coordinator is permitted to pick its own value during the replication phase, the coordinator can issue a special "),i("code",[e._v("Any")]),e._v(" message to acceptors, making acceptors accept values from any proposer")])])]),e._v(" "),i("li",[e._v("prone to collisions — if two or more proposers attempt to use the fast step, the coordinator has to intervene and start recovery by initiating a new round")])])]),e._v(" "),i("li",[i("p",[e._v("egalitarian Paxos, aka. EPaxos — benefits of both classic Paxos where leader established each round, and multi-Paxos where leader can be hot spot but high throughput")]),e._v(" "),i("ul",[i("li",[e._v("dependency conflict checking, tbd")])])]),e._v(" "),i("li",[i("p",[e._v("flexible Paxos — use R + W > N as quorum, allows trading availability for latency")]),e._v(" "),i("ul",[i("li",[e._v("example — if we have five acceptors, as long as we require collecting votes from four of them to win the election round, we can allow the leader to wait for responses from two nodes during the replication stage")]),e._v(" "),i("li",[e._v("variants — vertical Paxos")])])]),e._v(" "),i("li",[i("p",[e._v("generalized solution — tbd, "),i("a",{attrs:{href:"https://arxiv.org/abs/1902.06776",target:"_blank",rel:"noopener noreferrer"}},[e._v("A Generalised Solution to Distributed Consensus"),i("OutboundLink")],1)])])]),e._v(" "),i("h2",{attrs:{id:"other"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#other"}},[e._v("#")]),e._v(" Other")]),e._v(" "),i("h3",{attrs:{id:"message-queues"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#message-queues"}},[e._v("#")]),e._v(" Message Queues")]),e._v(" "),i("ol",[i("li",[i("p",[e._v("message queue")]),e._v(" "),i("ul",[i("li",[e._v("model\n"),i("ul",[i("li",[e._v("point to point — JMS queues, like producer / consumer or load balance model, message can only be acknowledged once")]),e._v(" "),i("li",[e._v("publish / subscribe — JMS topics, like events\n"),i("ul",[i("li",[e._v("durable and non-durable subscriber — whether message persisted for unreachable subscribes")])])]),e._v(" "),i("li",[e._v("集群订阅 middleware — publish / subscribe for clusters, PTP for nodes in clusters")])])]),e._v(" "),i("li",[e._v("message acknowledgement in JMS\n"),i("ul",[i("li",[i("code",[e._v("AUTO_ACKNOWLEDGE")]),e._v(" — after the reception of message (when the session has successfully returned from a call to receive or when the message listener called to process the message successfully returns)")]),e._v(" "),i("li",[i("code",[e._v("CLIENT_ACKNOWLEDGE")]),e._v(" — after "),i("code",[e._v("javax.jms.Message::acknowledge")])]),e._v(" "),i("li",[i("code",[e._v("DUPS_OK_ACKNOWLEDGE")]),e._v(" — batched, sends a client acknowledgment each time received a fixed number of messages, or when a fixed time interval has elapsed since the last acknowledgment was sent; the broker may redeliver the same message more than once")]),e._v(" "),i("li",[i("code",[e._v("SESSION_TRANSACTED")]),e._v(" — deliver and consume messages in a local transaction")])])]),e._v(" "),i("li",[e._v("purpose\n"),i("ul",[i("li",[e._v("decoupling")]),e._v(" "),i("li",[e._v("pipelining — Requests in different stages are processed by independent parts of the system. The subsystem responsible for receiving messages doesn’t have to block until the previous message is fully processed.")]),e._v(" "),i("li",[e._v("absorbing short-time bursts")])])]),e._v(" "),i("li",[e._v("可靠性\n"),i("ul",[i("li",[e._v("发送端的可靠性 — 发送端完成操作后一定能将消息成功发送到消息队列中\n"),i("ul",[i("li",[e._v("implementation: 使用本地事务 — 利用本地事务来保证在对本地消息表与业务数据表的操作满足事务特性，并且使用了消息队列来保证最终一致性：将消息表中的消息转移到消息队列中，若转移消息成功则删除消息表中的数据，否则继续重传\n"),i("ul",[i("li",[e._v("限制：有时发送消息和业务操作难以集成在一个本地事务 — resort to distributed transactions")])])]),e._v(" "),i("li",[e._v("implementation: message middleware with message state\n"),i("ul",[i("li",[e._v("send message\n"),i("ol",[i("li",[e._v("producer send message with pending state to message middleware")]),e._v(" "),i("li",[e._v("message middleware store the message and ACK")]),e._v(" "),i("li",[e._v("producer do business logics")]),e._v(" "),i("li",[e._v("producer send the result of business logics to the message middleware, also complete the message content if necessary")]),e._v(" "),i("li",[e._v("message middleware change the message state accordingly: enable consuming for the message if success, delete the message otherwise")])])]),e._v(" "),i("li",[e._v("polling for message state if the producer fail to update")])])])])]),e._v(" "),i("li",[e._v("接收端的可靠性 — no duplicated consumption\n"),i("ul",[i("li",[e._v("possible implementation\n"),i("ul",[i("li",[e._v("idempotent message consuming")]),e._v(" "),i("li",[e._v("保证消息具有唯一编号，并使用一张日志表来记录已经消费的消息编号")])])])])])])]),e._v(" "),i("li",[e._v("optimization\n"),i("ul",[i("li",[e._v("producer\n"),i("ul",[i("li",[e._v("asynchronous sending — do not wait ACK after message sent")]),e._v(" "),i("li",[e._v("ProducerFlowControl — 消息堆积，井超过限制大小的情况下，ActiveMQ 就会让消息生产者进入等待状态或者在发送者端直接抛出 "),i("code",[e._v("JMSException")]),e._v("; 需要设置回执窗口，发送若干次后等待服务端进行回执")])])]),e._v(" "),i("li",[e._v("consumer\n"),i("ul",[i("li",[e._v("dispatch async — 推送消息后，不会等待消费者的响应信息，直到消费者处理完消息后，主动向服务端返回处理结果")]),e._v(" "),i("li",[e._v("prefetch — 主动按照设置的规则推送给当前活动的消费者")]),e._v(" "),i("li",[e._v("dead letter queue — transfer the message to dead letter queue when the redeliver count exceeds threshold")]),e._v(" "),i("li",[e._v("transaction or ACK\n"),i("ul",[i("li",[e._v("transaction — messages redelivered to the same session upon rollback, or failure to commit")]),e._v(" "),i("li",[e._v("ACK — refrain from synchronous individual ACK")])])])])])])]),e._v(" "),i("li",[e._v("other features\n"),i("ul",[i("li",[e._v("message priority")])])])])]),e._v(" "),i("li",[i("p",[e._v("delayed queue")]),e._v(" "),i("ul",[i("li",[e._v("use cases — timed events, like notification push, auto canceling")]),e._v(" "),i("li",[e._v("Redis ZSet polling\n"),i("ul",[i("li",[e._v("add — "),i("code",[e._v("ZADD key timestamp task")]),e._v(", also using consistent hashing to distribute on different keys for performance and scalability")]),e._v(" "),i("li",[e._v("polling — "),i("code",[e._v("ZRANGEBYSCORE key -inf +inf limit 0 1 WITHSCORES")]),e._v(", one or more processes for one or more keys")]),e._v(" "),i("li",[e._v("async execution — for example, send to normal message queue")])])]),e._v(" "),i("li",[e._v("RabbitMQ — TTL as delay, or directly use the "),i("a",{attrs:{href:"https://www.rabbitmq.com/community-plugins.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("community delayed message exchange plugin"),i("OutboundLink")],1),e._v(" "),i("ul",[i("li",[e._v("dead lettering — message posted to dead letter exchange to be redirected to dead letter queue when: message rejected using "),i("code",[e._v("basic.reject")]),e._v(" or "),i("code",[e._v("basic.nack")]),e._v(" with "),i("code",[e._v("requeue")]),e._v(" "),i("code",[e._v("false")]),e._v("; message TTL timed out; message queue length exceeded")]),e._v(" "),i("li",[e._v("TTL — TTL of a queue, expired timely; TTL of a message, expiration examined when at queue head, use the community plugin above to support delay for each message")])])]),e._v(" "),i("li",[e._v("time wheel — circular list, each node as message queues\n"),i("ul",[i("li",[e._v("add — O(1), e.g. if the pointer points to 2 at the moment, add the task with 3s delay at 5")]),e._v(" "),i("li",[e._v("hierarchical — like second hands, minute hands, hour hands on watches")]),e._v(" "),i("li",[e._v("empty bucket optimization in Kafka — use "),i("code",[e._v("java.util.concurrent.DelayQueue")]),e._v(" to spin the time wheel")])])])])])]),e._v(" "),i("h3",{attrs:{id:"distributed-locks"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#distributed-locks"}},[e._v("#")]),e._v(" Distributed Locks")]),e._v(" "),i("ol",[i("li",[i("p",[e._v("unique index of a database — insert a record as lock acquiring, delete the record as lock releasing")]),e._v(" "),i("ul",[i("li",[e._v("plain unique index in traditional relational database\n"),i("ul",[i("li",[e._v("problems\n"),i("ul",[i("li",[e._v("no lease or timeout")]),e._v(" "),i("li",[e._v("can only be non-blocking")]),e._v(" "),i("li",[e._v("not reentrant")])])])])]),e._v(" "),i("li",[i("code",[e._v("SETNX")]),e._v(" in Redis — can set "),i("code",[e._v("EXPIRE")]),e._v(" for the key, see "),i("a",{attrs:{href:"https://redis.io/topics/distlock",target:"_blank",rel:"noopener noreferrer"}},[e._v("redis.io"),i("OutboundLink")],1),e._v(" "),i("ul",[i("li",[e._v("deprecated — "),i("code",[e._v("SETNX")]),e._v(" then "),i("code",[e._v("EXPIRE")]),e._v(" not atomic, use "),i("code",[e._v("SET")]),e._v(" with parameters instead"),i("div",{staticClass:"language- extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[e._v("SET key value [EX seconds|PX milliseconds|KEEPTTL] [NX|XX] [GET]\n")])])])]),e._v(" "),i("li",[e._v("possible to "),i("code",[e._v("DEL")]),e._v(" key owned by other client — when the lock expired before a client can finish its operation\n"),i("ul",[i("li",[e._v("solution — use client ID or random string as the value")]),e._v(" "),i("li",[e._v("if ID as value — use lua script to atomically compare and delete the lock")])])]),e._v(" "),i("li",[e._v("problem: lock lost — the underlying Redis instance failed before the very key is replicated")])])]),e._v(" "),i("li",[i("code",[e._v("RedissonLock")]),e._v(" in redisson, a Redis Java client — lua scripts encapsulated, also reentrant")])])]),e._v(" "),i("li",[i("p",[e._v("RedLock — use several "),i("strong",[e._v("independent")]),e._v(" Redis instances, see "),i("a",{attrs:{href:"https://redis.io/topics/distlock",target:"_blank",rel:"noopener noreferrer"}},[e._v("redis.io"),i("OutboundLink")],1)]),e._v(" "),i("ul",[i("li",[e._v("steps\n"),i("ol",[i("li",[e._v("try to acquire lock from multiple Redis instances one by one, with a smaller timeout compared to lock validity time\n"),i("ul",[i("li",[e._v("retry — jittered backoff, waits a time which is comparably greater than the time needed to acquire the majority of locks")]),e._v(" "),i("li",[e._v("multiplexing — the faster a client tries to acquire the lock in the majority of Redis instances, the smaller the window for a split brain condition (and the need for a retry), so ideally the client should try to send the "),i("code",[e._v("SET")]),e._v(" commands to the N instances at the same time using multiplexing")])])]),e._v(" "),i("li",[e._v("iff a quorum (majority) of locks acquired and the time spent acquiring the lock is less than lock TTL, the lock is acquired, validity time is considered to be the initial validity time minus the time elapsed")]),e._v(" "),i("li",[e._v("release locks on each instance if failed to acquire lock, even the instances it believed it was not able to lock")])])]),e._v(" "),i("li",[e._v("variant: extend TTL when needed — use small TTL, but the client may extend the lock by sending a Lua script to all the instances that extends the TTL of the key if the key exists and its value is still the random value the client assigned when the lock was acquired, also majority required\n"),i("ul",[i("li",[e._v("ensure liveness — the maximum number of lock reacquisition attempts should be limited")])])])])]),e._v(" "),i("li",[i("p",[e._v("sequence nodes in ZooKeeper — see "),i("a",{attrs:{href:"https://zookeeper.apache.org/doc/r3.4.14/recipes.html#sc_recipes_Locks",target:"_blank",rel:"noopener noreferrer"}},[e._v("ZooKeeper official docs"),i("OutboundLink")],1)]),e._v(" "),i("ul",[i("li",[e._v("ZooKeeper namespace — hierarchical, each node in a ZooKeeper namespace can have data associated with it as well as children, like having a file-system that allows a file to also be a directory"),i("br"),e._v(" "),i("img",{attrs:{src:"https://zookeeper.apache.org/doc/r3.4.14/images/zknamespace.jpg",alt:""}})]),e._v(" "),i("li",[e._v("znode\n"),i("ul",[i("li",[e._v("normal node")]),e._v(" "),i("li",[e._v("ephemeral node — exists as long as the session that created the znode is active, not allowed to have children")]),e._v(" "),i("li",[e._v("sequence node — unique naming: when creating a znode you can also request that ZooKeeper append a monotonically increasing counter to the end of path")])])]),e._v(" "),i("li",[e._v("ZooKeeper watches — a watch event is one-time trigger, sent to the client that set the watch, which occurs when the data for which the watch was set changes")]),e._v(" "),i("li",[e._v("acquire a lock\n"),i("ol",[i("li",[e._v("call "),i("code",[e._v("create( )")]),e._v(" with a pathname of "),i("code",[e._v('"_locknode_/guid-lock-"')]),e._v(" and the sequence and ephemeral flags set. The guid is needed in case the "),i("code",[e._v("create()")]),e._v(" result is missed")]),e._v(" "),i("li",[e._v("call "),i("code",[e._v("getChildren( )")]),e._v(" on the lock node without setting the watch flag (this is important to avoid the herd effect).")]),e._v(" "),i("li",[e._v("if the pathname created in step 1 has the lowest sequence number suffix, the client has the lock and the client exits the protocol.")]),e._v(" "),i("li",[e._v("the client calls "),i("code",[e._v("exists( )")]),e._v(" with the watch flag set on the path in the lock directory with the next lowest sequence number.")]),e._v(" "),i("li",[e._v("if "),i("code",[e._v("exists( )")]),e._v(" returns null, go to step 2. Otherwise, wait for a notification for the pathname from the previous step before going to step 2.")])])]),e._v(" "),i("li",[e._v("unlock — the client delete the node it created")]),e._v(" "),i("li",[e._v("advantages\n"),i("ul",[i("li",[e._v("avoid herd effect — the removal of a node will only cause one client to wake up")]),e._v(" "),i("li",[e._v("no polling or timeouts — ephemeral nodes deleted when session is not active, session expiration is managed by the ZooKeeper cluster")]),e._v(" "),i("li",[e._v("monitor friendly — it is easy to see the amount of lock contention, break locks, debug locking problems, etc.")])])])])])]),e._v(" "),i("h3",{attrs:{id:"clustering"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#clustering"}},[e._v("#")]),e._v(" Clustering")]),e._v(" "),i("ol",[i("li",[i("p",[e._v("Load Balance")]),e._v(" "),i("ul",[i("li",[e._v("round robin\n"),i("ul",[i("li",[e._v("example — DNS, LVS, Nginx, ZooKeeper")]),e._v(" "),i("li",[e._v("variant — weighted round robin\n"),i("ul",[i("li",[e._v("weights — according to server metrics, such as performance")]),e._v(" "),i("li",[e._v("distribution — according to algorithms, such as Monte-Carlo, GCD")])])])])]),e._v(" "),i("li",[e._v("least connections\n"),i("ul",[i("li",[e._v("variant — weighted least connections")])])]),e._v(" "),i("li",[e._v("random\n"),i("ul",[i("li",[e._v("variant — the choice-of-2 算法，随机选取的两个节点进行打分，选择更优的节点")])])]),e._v(" "),i("li",[e._v("hash\n"),i("ul",[i("li",[e._v("mod hash")]),e._v(" "),i("li",[e._v("consistent hashing — "),i("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/34985026",target:"_blank",rel:"noopener noreferrer"}},[e._v("zhihu"),i("OutboundLink")],1)])])])])]),e._v(" "),i("li",[i("p",[e._v("Redirect")]),e._v(" "),i("ul",[i("li",[e._v("HTTP 302 Found — one more roundtrip")]),e._v(" "),i("li",[e._v("DNS level load balance and redirect\n"),i("ul",[i("li",[e._v("geological proximity")]),e._v(" "),i("li",[e._v("long config deployment time")])])]),e._v(" "),i("li",[e._v("server proxy\n"),i("ul",[i("li",[e._v("normal server proxy")]),e._v(" "),i("li",[e._v("network layer server proxy gateway, modifying IP")]),e._v(" "),i("li",[e._v("data link layer server, modifying MAC address\n"),i("ul",[i("li",[e._v("直接路由 — 三角传输模式，通过配置源服务器的虚拟 IP 地址和负载均衡服务器的 IP 地址一致，从而不需要修改 IP 地址就可以进行转发。也正因为 IP 地址一样，所以源服务器的响应不需要转发回负载均衡服务器，可以直接转发给客户端，避免了负载均衡服务器的成为瓶颈")]),e._v(" "),i("li",[e._v("example — LVS")])])])])])])]),e._v(" "),i("li",[i("p",[e._v("session")]),e._v(" "),i("ul",[i("li",[e._v("sticky session")]),e._v(" "),i("li",[e._v("session replication")]),e._v(" "),i("li",[e._v("session server")])])])])])}),[],!1,null,null,null);t.default=o.exports}}]);