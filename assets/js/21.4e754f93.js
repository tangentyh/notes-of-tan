(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{231:function(e,a,t){"use strict";t.r(a);var n=t(0),r=Object(n.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"JVM"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#JVM"}},[e._v("#")]),e._v(" JVM")]),e._v(" "),t("ol",[t("li",[e._v("JVM in "),t("code",[e._v("System")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("static void exit(int status)")])]),e._v(" "),t("li",[t("code",[e._v("static void gc()")]),e._v(" — run garbage collector")]),e._v(" "),t("li",[t("code",[e._v("static Channel inheritedChannel()")]),e._v(" — the channel inherited from the entity that created this Java virtual machine")]),e._v(" "),t("li",[t("code",[e._v("static void load(String filename)")])]),e._v(" "),t("li",[t("code",[e._v("static void loadLibrary(String libname)")])]),e._v(" "),t("li",[t("code",[e._v("static String mapLibraryName(String libname)")])]),e._v(" "),t("li",[t("code",[e._v("static void runFinalization()")])]),e._v(" "),t("li",[t("code",[e._v("static SecurityManager getSecurityManager()")])]),e._v(" "),t("li",[t("code",[e._v("static void setSecurityManager(SecurityManager s)")])])])])]),e._v(" "),t("h2",{attrs:{id:"Memory"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#Memory"}},[e._v("#")]),e._v(" Memory")]),e._v(" "),t("ol",[t("li",[t("p",[e._v("threads")]),e._v(" "),t("ul",[t("li",[e._v("system threads, besides the main thread\n"),t("ul",[t("li",[e._v('VM thread — waits for operations to appear that require the JVM to reach a safe-point where modifications to the heap can not occur; operations are "stop-the-world" garbage collections, thread stack dumps, thread suspension and biased locking revocation')]),e._v(" "),t("li",[e._v("period task thread — responsible for timer events (i.e. interrupts) that are used to schedule execution of periodic operations")]),e._v(" "),t("li",[e._v("GC thread — literally")]),e._v(" "),t("li",[e._v("compiler thread — JIT")]),e._v(" "),t("li",[e._v("signal dispatcher thread — receives signals sent to the JVM process and handle them inside the JVM by calling the appropriate JVM methods")])])]),e._v(" "),t("li",[e._v("errors — "),t("code",[e._v("StackOverflowError")]),e._v(", "),t("code",[e._v("OutOfMemoryError")]),e._v(" for frames")])])]),e._v(" "),t("li",[t("p",[e._v("memory model per thread")]),e._v(" "),t("ul",[t("li",[e._v("program counter (PC) — address of the current instruction (or opcode), or undefined if the current method is native, typically incremented after each instruction; pointing at a memory address in the Method Area")]),e._v(" "),t("li",[e._v("native stack — for JNI")]),e._v(" "),t("li",[e._v("stack — LIFO queue for frames for each method executing on the thread; no direct manipulation except pop and push, so frame objects may be allocated in the Heap and the memory does not need to be contiguous\n"),t("ul",[t("li",[e._v("CLI — "),t("code",[e._v("-Xss")]),e._v(", e.g. "),t("code",[e._v("-Xss64m")])])])]),e._v(" "),t("li",[e._v("frame — element in stack, fixed size after creation\n"),t("ul",[t("li",[e._v("local variable array — containing "),t("code",[e._v("this")]),e._v(" if not static, method parameters and local variables (primitive types, reference and return address)")]),e._v(" "),t("li",[e._v("return value")]),e._v(" "),t("li",[e._v("operand stack — analogous to general purpose registers used in CPU; most JVM byte code spends its time manipulating the operand stack by pushing, popping, duplicating, swapping, or executing operations that produce or consume values, as well as move values between the local variable array and the operand stack")]),e._v(" "),t("li",[e._v("reference to runtime constant pool for the class of the current method — references to variables and methods compiled as symbolic references stored in the class's constant pool\n"),t("ul",[t("li",[e._v("binding — the process of the field, method or class identified by the symbolic reference being completely replaced by a direct reference")])])])])])])]),e._v(" "),t("li",[t("p",[e._v("memory model shared between threads")]),e._v(" "),t("ul",[t("li",[e._v("heap — where objects allocated\n"),t("ul",[t("li",[e._v("young generation\n"),t("ul",[t("li",[e._v("Eden")]),e._v(" "),t("li",[e._v("survivor")]),e._v(" "),t("li",[e._v("CLI — "),t("code",[e._v("-Xmn")]),e._v(", "),t("code",[e._v("-XX:SurvivorRatio=8")])])])]),e._v(" "),t("li",[e._v("old (or tenure) generation")]),e._v(" "),t("li",[e._v("CLI — "),t("code",[e._v("-Xms")]),e._v(" for initial value, "),t("code",[e._v("-Xmx")]),e._v(" for max value")])])]),e._v(" "),t("li",[e._v("permanent generation (removed since JDK 8), allocated as part of contiguous memory as the Java heap\n"),t("ul",[t("li",[e._v("interned strings (string table), can be explicitly interned by "),t("code",[e._v("String::intern")]),e._v(", moved to heap since JDK 8\n"),t("ul",[t("li",[e._v("CLI — "),t("code",[e._v("-XX:+PrintStringTableStatistics")])])])]),e._v(" "),t("li",[e._v("method area — must be thread-safe\n"),t("ul",[t("li",[e._v("class loader reference")]),e._v(" "),t("li",[e._v("runtime constant pool — numeric constants - field references - method references - attributes")]),e._v(" "),t("li",[e._v("class info\n"),t("ul",[t("li",[e._v("field data — name - type - modifiers - attributes")]),e._v(" "),t("li",[e._v("method data — name - return type - parameter types (in order) - modifiers - attributes")]),e._v(" "),t("li",[e._v("method code\n"),t("ul",[t("li",[e._v("bytecodes")]),e._v(" "),t("li",[e._v("operand stack size - local variable size - local variable table")]),e._v(" "),t("li",[e._v("exception table\n"),t("ul",[t("li",[e._v("per exception handler — start point - end point - PC offset for handler code - constant pool index for exception class being caught")])])])])])])])])])])]),e._v(" "),t("li",[e._v("metaspace, replacement for permanent generation since JDK 8\n"),t("ul",[t("li",[e._v("held in native memory and not related to heap — PermGen had a fixed size, but "),t("code",[e._v("MaxMetaspaceSize")]),e._v(" defaults to infinity, no more "),t("code",[e._v("java.lang.OutOfMemoryError: Permgen space")]),e._v(" ("),t("code",[e._v("OutOfMemoryError")]),e._v(" for metaspace is still possible)")]),e._v(" "),t("li",[e._v("GC — triggered once the "),t("code",[e._v("MaxMetaspaceSize")]),e._v(" is reached")]),e._v(" "),t("li",[e._v("CLI — "),t("code",[e._v("-XX:MetaspaceSize")]),e._v(", "),t("code",[e._v("-XX:MaxMetaspaceFreeRatio")]),e._v(", "),t("code",[e._v("-XX — MinMetaspaceFreeRatio")]),e._v(", "),t("code",[e._v("-XX — MaxMetaspaceSize")])])])]),e._v(" "),t("li",[e._v("code cache — for JIT\n"),t("ul",[t("li",[e._v("CLI — "),t("code",[e._v("-XX:ReservedCodeCacheSize=128m")]),e._v(", "),t("code",[e._v("-XX:InitialCodeCacheSize")])])])]),e._v(" "),t("li",[t("code",[e._v("sun.nio.ch.DirectBuffer")]),e._v(" — use native methods to manipulate non-heap memory, read and write directly to a memory address, used in NIO")])])])]),e._v(" "),t("h2",{attrs:{id:"GC"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#GC"}},[e._v("#")]),e._v(" GC")]),e._v(" "),t("ol",[t("li",[t("p",[e._v("GC")]),e._v(" "),t("ul",[t("li",[e._v("GC target detection\n"),t("ul",[t("li",[e._v("reference count — not used by JVM due to circular reference")]),e._v(" "),t("li",[e._v("reachability detection — DFS from GC roots\n"),t("ul",[t("li",[e._v("自救 — make the object reachable in "),t("code",[e._v("Object::finalize")]),e._v(", 自救只能进行一次，"),t("code",[e._v("Object::finalize")]),e._v(" will not be called twice")]),e._v(" "),t("li",[e._v("necessity when unload a class in permanent generation or metaspace — instances and class loader of this class garbage collected, no "),t("code",[e._v("Class")]),e._v(" instance reference")])])])])]),e._v(" "),t("li",[e._v("GC type\n"),t("ul",[t("li",[e._v("minor GC — GC in young generation, where lifespan is short, move alive objects from Eden to survivor, executed frequently and relatively fast, triggered when not enough space in Eden")]),e._v(" "),t("li",[e._v("full GC — typically pause the application threads, GC in both generations and also permanent generation")]),e._v(" "),t("li",[e._v("major GC — GC in tenure generation, only in CMS")]),e._v(" "),t("li",[e._v("mixed GC — GC in young and part of tenure generation, only in G1??")])])]),e._v(" "),t("li",[e._v("full GC trigger\n"),t("ul",[t("li",[t("code",[e._v("System::gc")])]),e._v(" "),t("li",[e._v("not enough space in old or permanent generation")]),e._v(" "),t("li",[e._v("promotion guarantee failed, see below")]),e._v(" "),t("li",[e._v("concurrent mode failure in CMS")])])]),e._v(" "),t("li",[e._v("memory management strategies\n"),t("ul",[t("li",[t("code",[e._v("new")]),e._v(" objects — created in Eden, minor GC if not enough space")]),e._v(" "),t("li",[e._v("pretenure — large "),t("code",[e._v("new")]),e._v(" objects directly created in tenure generation, specified as "),t("code",[e._v("-XX:PretenureSizeThreshold")])]),e._v(" "),t("li",[e._v("promotion by age — every move to Survivor increments the age by 1, move to tenure generation when age "),t("code",[e._v("-XX:MaxTenuringThreshold")])]),e._v(" "),t("li",[e._v("dynamic promotion — 如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 "),t("code",[e._v("MaxTenuringThreshold")])]),e._v(" "),t("li",[e._v("promotion guarantee — 在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的; after JDK 6, "),t("code",[e._v("-XX:-HandlePromotionFailure")]),e._v(" removed，只要老年代的连续空间大于新生代对象的总大小或者历次晋升到老年代的对象的平均大小就进行 minor GC，否则 full GC")])])]),e._v(" "),t("li",[e._v("GC algorithm\n"),t("ul",[t("li",[e._v("mark sweep\n"),t("ul",[t("li",[e._v("steps\n"),t("ul",[t("li",[e._v("mark — mark reachable objects, stop-the-world")]),e._v(" "),t("li",[e._v("sweep — collected the unmarked and erase marks, merge if contiguous to the previous free block, freed space added to a single linked list called free list")])])]),e._v(" "),t("li",[e._v("free list — searched when allocate new objects to find enough space")]),e._v(" "),t("li",[e._v("disadvantages — segmentation; low performance")])])]),e._v(" "),t("li",[e._v("mark compact\n"),t("ul",[t("li",[e._v("compact — move active objects to one end, no segmentation but stop-the-world")])])]),e._v(" "),t("li",[e._v("mark copy — divide memory into two regions\n"),t("ul",[t("li",[e._v("copy — copies all alive objects to the other region")])])]),e._v(" "),t("li",[e._v("mark copy in HotSpot — Eden:survivor defaults to 8:(1 + 1), copy from Eden and one survivor to the other survivor, if not enough space, move to tenure generation")]),e._v(" "),t("li",[e._v("hybrid — mark copy for young generation, mark sweep or compact for tenure generation")])])])])]),e._v(" "),t("li",[t("p",[e._v("garbage collectors")]),e._v(" "),t("ul",[t("li",[e._v("categorization\n"),t("ul",[t("li",[e._v("for young generation — serial, ParNew, parallel scavenge, G1")]),e._v(" "),t("li",[e._v("for tenure generation — CMS, serial old (MSC), parallel old, G1")]),e._v(" "),t("li",[e._v("stop-the-world — above all except CMS and G1")]),e._v(" "),t("li",[e._v("combination of young and tenure\n"),t("ul",[t("li",[e._v("serial — serial old, CMS")]),e._v(" "),t("li",[e._v("ParNew — serial old, CMS")]),e._v(" "),t("li",[e._v("parallel scavenge — serial old, parallel old")])])])])]),e._v(" "),t("li",[e._v("default GC\n"),t("ul",[t("li",[e._v("since JDK 9 — G1")]),e._v(" "),t("li",[e._v("JDK 8\n"),t("ul",[t("li",[e._v("parallel GC for server class machine (with at least 2 processors and at least 2 GB of physical memory)")]),e._v(" "),t("li",[e._v("serial GC for client class machine (single processor or 32-bit platform)")])])])])]),e._v(" "),t("li",[e._v("serial — mark-copy, single thread, about 100ms for 100 to 200M garbage\n"),t("ul",[t("li",[e._v("serial old — serial GC for tenure generation, mark-compact, can serve as backup for CMS")])])]),e._v(" "),t("li",[e._v("ParNew — serial GC but multithread")]),e._v(" "),t("li",[e._v("parallel scavenge — similar to ParNew, but throughput (user CPU time versus total CPU time) first in contrast to minimizing pause time, better UX being more responsive with small pause time although smaller young generation and more frequent GC\n"),t("ul",[t("li",[e._v("parallel old — parallel scavenge for tenure generation")]),e._v(" "),t("li",[e._v("GC ergonomics — with "),t("code",[e._v("-XX:+UseAdaptiveSizePolicy")]),e._v(", 不需要手工指定新生代的大小（-Xmn）、Eden 和 Survivor 区的比例、晋升老年代对象年龄等细节参数了。JVM 会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量, "),t("code",[e._v("-XX:AdaptiveSizePolicyOutputInterval=1")]),e._v(" for logging")])])]),e._v(" "),t("li",[e._v("CMS, concurrent mark sweep — "),t("a",{attrs:{href:"https://plumbr.io/handbook/garbage-collection-algorithms-implementations/concurrent-mark-and-sweep",target:"_blank",rel:"noopener noreferrer"}},[e._v("blog"),t("OutboundLink")],1),e._v(" "),t("ul",[t("li",[e._v("disadvantages\n"),t("ul",[t("li",[e._v("low throughput")]),e._v(" "),t("li",[e._v("concurrent mode failure — the CMS collector is unable to finish reclaiming the unreachable objects before the tenured generation fills up, or if an allocation cannot be satisfied with the available free space blocks in the tenured generation; serial old as backup\n"),t("ul",[t("li",[e._v("float garbage — objects that are traced by the garbage collector (reachable) thread may subsequently become unreachable by the time collection process ends, due to concurrently running application thread")])])]),e._v(" "),t("li",[e._v("segmentation from mark sweep")])])]),e._v(" "),t("li",[e._v("phases\n"),t("ol",[t("li",[e._v("initial mark — stop-the-world but fast, mark objects directly connected to GC roots")]),e._v(" "),t("li",[e._v("concurrent mark — most time-consuming phase\n"),t("ul",[t("li",[e._v("card marking — marks the area of the heap (called “card”) that contains the mutated object since last phase as “dirty”")])])]),e._v(" "),t("li",[e._v("concurrent preclean — accounting for references being changed during previous marking phase, making dirty cards clean")]),e._v(" "),t("li",[e._v("concurrent-abortable-preclean — like the previous phase, tbd")]),e._v(" "),t("li",[e._v("final remark — stop-the-world, finalize marking all live objects in the old generation")]),e._v(" "),t("li",[e._v("concurrent sweep")]),e._v(" "),t("li",[e._v("concurrent reset — resetting inner data structures of the CMS algorithm and preparing them for the next cycle")])])])])]),e._v(" "),t("li",[e._v("G1, garbage first\n"),t("ul",[t("li",[e._v("region — G1 divides heap into different regions and the young and tenure generation is not physically separated. 通过记录每个 Region 垃圾回收时间以及回收所获得的空间，并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region")]),e._v(" "),t("li",[e._v("remembered set — keep track of regionA -> regionB connection; when scanning regionB refer to remembered set to find out if need to scan regionA")]),e._v(" "),t("li",[e._v("phases except remembered set maintainence — like CMS, initial mark, concurrent mark, final remark, cleanup (partially concurrent)\n"),t("ul",[t("li",[e._v("cleanup — sort regions by GC cost and value, use a pause prediction model to meet a user-defined pause time target and select the number of regions to collect based on the specified pause time target")]),e._v(" "),t("li",[t("a",{attrs:{href:"https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Introduction on Oracle"),t("OutboundLink")],1)])])]),e._v(" "),t("li",[e._v("advantages\n"),t("ul",[t("li",[e._v("concurrent like CMS")]),e._v(" "),t("li",[e._v("space compact, mark compact as a whole while being copy between regions")]),e._v(" "),t("li",[e._v("predictable GC pause durations")])])])])]),e._v(" "),t("li",[e._v("ZGC — shorter pause than Shenandoah, tbd")]),e._v(" "),t("li",[e._v("Shenandoah — higher throughput than ZGC, tbd")])])]),e._v(" "),t("li",[t("p",[e._v("GC CLI")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("-XX:+UseSerialGC")]),e._v(" — 在新生代和老年代使用串行收集器")]),e._v(" "),t("li",[t("code",[e._v("-XX:+UseParNewGC")]),e._v(" — 在新生代使用并行收集器")]),e._v(" "),t("li",[t("code",[e._v("-XX:+UseParallelGC")]),e._v(" — 新生代使用并行回收收集器，更加关注吞吐量")]),e._v(" "),t("li",[t("code",[e._v("-XX:+UseParallelOldGC")]),e._v(" — 老年代使用并行回收收集器")]),e._v(" "),t("li",[t("code",[e._v("-XX:+UseConcMarkSweepGC")]),e._v(" — 新生代使用并行收集器，老年代使用CMS+串行收集器\n"),t("ul",[t("li",[t("code",[e._v("-XX:ParallelCMSThreads")]),e._v(" — 设定CMS的线程数量")])])]),e._v(" "),t("li",[t("code",[e._v("-XX:+UseG1GC")]),e._v(" — 启用G1垃圾回收器\n"),t("ul",[t("li",[t("code",[e._v("-XX:G1HeapRegionSize")]),e._v(", "),t("code",[e._v("-XX:G1NewSizePercent")]),e._v(", "),t("code",[e._v("-XX:G1MaxNewSizePercent")])])])]),e._v(" "),t("li",[t("code",[e._v("-XX:+UnlockExperimentalVMOptions")]),e._v(" "),t("code",[e._v("-XX:+UseZGC")]),e._v(" — 启用ZGC\n"),t("ul",[t("li",[t("code",[e._v("-XX:ZCollectionInterval")]),e._v(" — ZGC发生的最小时间间隔，单位秒")]),e._v(" "),t("li",[t("code",[e._v("-XX:ZAllocationSpikeTolerance")]),e._v(" — ZGC触发自适应算法的修正系数，默认2，数值越大，越早的触发ZGC")]),e._v(" "),t("li",[t("code",[e._v("-XX:+UnlockDiagnosticVMOptions")]),e._v(" "),t("code",[e._v("-XX:-ZProactive")]),e._v(" — 是否启用主动回收，默认开启，这里的配置表示关闭。")])])]),e._v(" "),t("li",[t("code",[e._v("-XX:+UseShenandoahGC")])]),e._v(" "),t("li",[t("code",[e._v("-XX:ParallelGCThreads")]),e._v(" — 设置用于垃圾回收的线程数")]),e._v(" "),t("li",[t("code",[e._v("-XX:ConcGCThreads")]),e._v(" — 并发回收垃圾的线程。默认是总核数的12.5%，8核CPU默认是1。调大后GC变快，但会占用程序运行时的CPU资源，吞吐会受到影响。")]),e._v(" "),t("li",[t("code",[e._v("-XX:MaxGCPauseMillis")])]),e._v(" "),t("li",[t("code",[e._v("-XX:PretenureSizeThreshold")])]),e._v(" "),t("li",[t("code",[e._v("-XX:InitiatingHeapOccupancyPercent")])]),e._v(" "),t("li",[t("code",[e._v("-Xlog")]),e._v(" — 设置GC日志中的内容、格式、位置以及每个日志的大小"),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("-Xlog:safepoint,classhisto*=trace,age*,gc*=info:file=/opt/logs/logs/gc-%t.log:time,tid,tags:filecount=5,filesize=50m\n-XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps -Xloggc:/home/logs/gc.log\n")])])])]),e._v(" "),t("li",[t("code",[e._v("-XX:+PrintCommandLineFlags")]),e._v(" — print flags, can check used GC configurations")])])])]),e._v(" "),t("h2",{attrs:{id:"Reference"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#Reference"}},[e._v("#")]),e._v(" Reference")]),e._v(" "),t("ol",[t("li",[t("p",[t("code",[e._v("java.lang.ref.Reference")])]),e._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("public")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("abstract")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("class")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Reference")]),t("span",{pre:!0,attrs:{class:"token generics"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("<")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("T")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(">")])]),e._v("\n")])])]),t("ul",[t("li",[t("code",[e._v("T get()")])]),e._v(" "),t("li",[t("code",[e._v("void clear()")])]),e._v(" "),t("li",[t("code",[e._v("boolean enqueue()")]),e._v(" — adds this reference object to the queue with which it is registered, if any, only by the program (GC can enqueue references without invoking this method, typically clear referents simultaneously)")]),e._v(" "),t("li",[t("code",[e._v("boolean isEnqueued()")])]),e._v(" "),t("li",[e._v("notification of changes in an object's reachability — by registering an appropriate reference object with a reference queue at the time the reference object is created")]),e._v(" "),t("li",[e._v("reachability: an object is\n"),t("ul",[t("li",[e._v("strongly reachable — if it can be reached by some thread without traversing any reference objects. A newly-created object is strongly reachable by the thread that created it.")]),e._v(" "),t("li",[e._v("softly reachable — if it is not strongly reachable but can be reached by traversing a soft reference")]),e._v(" "),t("li",[e._v("weakly reachable — if it is neither strongly nor softly reachable but can be reached by traversing a weak reference. When the weak references to a weakly-reachable object are cleared, the object becomes eligible for finalization.")]),e._v(" "),t("li",[e._v("phantom reachable — if it is neither strongly, softly, nor weakly reachable, it has been finalized, and some phantom reference refers to it")]),e._v(" "),t("li",[e._v("unreachable — if it is not reachable in any of the above ways, eligible for reclamation")])])]),e._v(" "),t("li",[e._v("package private constructor for override\n"),t("ul",[t("li",[t("code",[e._v("Reference(T referent)")])]),e._v(" "),t("li",[t("code",[e._v("Reference(T referent, ReferenceQueue<? super T> queue)")]),e._v(" — registered with the given queue")])])]),e._v(" "),t("li",[e._v("subclasses\n"),t("ul",[t("li",[t("code",[e._v("SoftReference")])]),e._v(" "),t("li",[t("code",[e._v("WeakReference")])]),e._v(" "),t("li",[t("code",[e._v("PhantomReference")])])])])])]),e._v(" "),t("li",[t("p",[e._v("strong reference")])]),e._v(" "),t("li",[t("p",[t("code",[e._v("java.lang.ref.SoftReference<T>")]),e._v(" — cleared at the discretion of the garbage collector in response to memory demand, guaranteed to have been cleared before "),t("code",[e._v("OutOfMemoryError")])]),e._v(" "),t("ul",[t("li",[e._v("use — for implementing memory-sensitive caches")])])]),e._v(" "),t("li",[t("p",[t("code",[e._v("java.lang.ref.WeakReference<T>")]),e._v(" — weak reference objects, which do not prevent their referents from being made finalizable, finalized, and then reclaimed; next GC")]),e._v(" "),t("ul",[t("li",[e._v("use — weak references are for implementing canonicalizing mappings that do not prevent their keys (or values) from being reclaimed")])])]),e._v(" "),t("li",[t("p",[t("code",[e._v("java.lang.ref.PhantomReference<T>")]),e._v(" — enqueued after the collector determines that their referents may otherwise be reclaimed")]),e._v(" "),t("ul",[t("li",[e._v("referent GC point\n"),t("ul",[t("li",[e._v("before Java 9 — unlike soft and weak references, phantom references are not automatically cleared by the GC as they are enqueued; an object that is reachable via phantom references will remain so until all such references are cleared or themselves become unreachable")]),e._v(" "),t("li",[e._v("since Java 9 — when phantom reachability detected, GC will atomically clear all phantom references to that object and all phantom references to any other phantom-reachable objects from which that object is reachable. At the same time or at some later time it will enqueue those newly-cleared phantom references that are registered with reference queues")])])]),e._v(" "),t("li",[e._v("use — a better "),t("code",[e._v("Object::finalize")]),e._v(" hook: for scheduling pre-mortem cleanup actions in a more flexible way than is possible with the Java finalization mechanism")]),e._v(" "),t("li",[t("code",[e._v("Object::finalize")]),e._v(" drawbacks\n"),t("ul",[t("li",[e._v("实例执行垃圾回收的周期更长，性能更低")]),e._v(" "),t("li",[e._v("单线程执行，因此在实例数目较多的情况下可能引起阻塞")]),e._v(" "),t("li",[e._v("会被子类所继承，在子类未知的情况下，影响子类的垃圾回收性能")]),e._v(" "),t("li",[e._v('不当的重载会导致原本已经"死亡"的实例"复活"')])])]),e._v(" "),t("li",[t("code",[e._v("get()")]),e._v(" — always return "),t("code",[e._v("null")]),e._v(" to ensure that a reclaimable object remains so")])])]),e._v(" "),t("li",[t("p",[t("code",[e._v("java.lang.ref.ReferenceQueue<T>")]),e._v(" — to which registered reference objects are appended by GC, at the same time or at some later time after detecting the reachability of the referent has changed to the value corresponding to the type of the reference")]),e._v(" "),t("ul",[t("li",[e._v("implementation — linked list, by "),t("code",[e._v("head")]),e._v(" field, "),t("code",[e._v("next")]),e._v(" field in "),t("code",[e._v("Reference")]),e._v(", and flags in "),t("code",[e._v("Reference")])]),e._v(" "),t("li",[t("code",[e._v("Reference<? extends T> poll()")]),e._v(" — non-block")]),e._v(" "),t("li",[t("code",[e._v("Reference<? extends T> remove()")]),e._v(" — block")]),e._v(" "),t("li",[t("code",[e._v("Reference<? extends T> remove(long timeout)")])])])])]),e._v(" "),t("h2",{attrs:{id:"Class-Loading"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#Class-Loading"}},[e._v("#")]),e._v(" Class Loading")]),e._v(" "),t("ol",[t("li",[t("p",[e._v("class file structure — tbd")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("ClassFile {\n    u4                magic;\n    u2                minor_version;\n    u2                major_version;\n    u2                constant_pool_count;\n    cp_info           contant_pool[constant_pool_count – 1];\n    u2                access_flags;\n    u2                this_class;\n    u2                super_class;\n    u2                interfaces_count;\n    u2                interfaces[interfaces_count];\n    u2                fields_count;\n    field_info        fields[fields_count];\n    u2                methods_count;\n    method_info       methods[methods_count];\n    u2                attributes_count;\n    attribute_info    attributes[attributes_count];\n}\n")])])]),t("ul",[t("li",[e._v("CLI — "),t("code",[e._v("javap -v -p -s -sysinfo -constants")])]),e._v(" "),t("li",[t("a",{attrs:{href:"https://blog.jamesdbloom.com/JVMInternals.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("ref"),t("OutboundLink")],1)])])]),e._v(" "),t("li",[t("p",[e._v("class loading")]),e._v(" "),t("ul",[t("li",[e._v("class loading process — only classes needed for execution loaded, using the class loader of the method caller\n"),t("ul",[t("li",[e._v("loading — load binary stream from disk or web into structures in method area and generate a "),t("code",[e._v("Class")]),e._v(" instance for the class")]),e._v(" "),t("li",[e._v("link\n"),t("ul",[t("li",[e._v("verifying — check semantics and safety like "),t("code",[e._v("final")]),e._v(", "),t("code",[e._v("private")]),e._v(" and variable types, etc.\n"),t("ul",[t("li",[e._v("bytecode verification — bytecode, except system classes, verified for safety before loaded into JVM")]),e._v(" "),t("li",[e._v("turn off on CLI — "),t("code",[e._v("-noverify")]),e._v(" (or "),t("code",[e._v("-Xverify:none")]),e._v(")")])])]),e._v(" "),t("li",[e._v("preparing — memory allocation for JVM, like method tables; static fields populated in method area")]),e._v(" "),t("li",[e._v("resolving — replace symbolic references with direct references\n"),t("ul",[t("li",[e._v("dynamic binding — resolving can happen after initializing for dynamic binding purposes")])])])])]),e._v(" "),t("li",[e._v("initializing — execute "),t("code",[e._v("<clinit>()")]),e._v(" for assignments of non-"),t("code",[e._v("final")]),e._v(" static fields and static blocks")])])]),e._v(" "),t("li",[e._v("class loaders\n"),t("ul",[t("li",[e._v("The bootstrap class loader — loads the system classes (typically, from the JAR file "),t("code",[e._v("rt.jar")]),e._v(", from modules since JDK 9)\n"),t("ul",[t("li",[e._v("usually implemented in C — as an integral part of the virtual machine, no "),t("code",[e._v("ClassLoader")]),e._v(" object involved, "),t("code",[e._v("String.class.getClassLoader()")]),e._v(" is "),t("code",[e._v("null")])])])]),e._v(" "),t("li",[e._v("The extension class loader — loads “standard extensions” from the "),t("code",[e._v("jre/lib/ext")]),e._v(" directory, the loader does not use the class path\n"),t("ul",[t("li",[e._v("no more "),t("code",[e._v("jre/lib/ext")]),e._v(" from JDK 9 — The javac compiler and java launcher will exit if the "),t("code",[e._v("java.ext.dirs")]),e._v(" system property is set, or if the "),t("code",[e._v("lib/ext")]),e._v(" directory exists")]),e._v(" "),t("li",[e._v("the platform class loader — the extension class loader is retained from JDK 9 and is specified as the platform class loader, see "),t("code",[e._v("ClassLoader::getPlatformClassLoader")])])])]),e._v(" "),t("li",[e._v("The system class loader (jdk internal "),t("code",[e._v("AppClassLoader")]),e._v(") — loads the application classes")])])]),e._v(" "),t("li",[e._v("class loader hierarchy\n"),t("ul",[t("li",[e._v("cosmic root — the bootstrap class loader")]),e._v(" "),t("li",[e._v("parents first — load only if the parent has failed")]),e._v(" "),t("li",[e._v("default parent when constructing "),t("code",[e._v("ClassLoader")]),e._v(" — system class loader")])])]),e._v(" "),t("li",[e._v("break parents first\n"),t("ul",[t("li",[e._v("use customized "),t("code",[e._v("ClassLoader")]),e._v(" — overloading "),t("code",[e._v("ClassLoader::loadClass")])]),e._v(" "),t("li",[e._v("use SPI — "),t("code",[e._v("Thread::getContextClassLoader")]),e._v(" under the hood, so built-in classes can use user classes")]),e._v(" "),t("li",[e._v("OSGi hot deployment")]),e._v(" "),t("li",[e._v("module from JDK 9 — defaults to using the class loader of the module if in a module")])])]),e._v(" "),t("li",[e._v("context class loader — each thread has a reference to a class loader\n"),t("ul",[t("li",[t("code",[e._v("Thread::getContextClassLoader")]),e._v(", "),t("code",[e._v("Thread::setContextClassLoader")])]),e._v(" "),t("li",[e._v("class loader inversion — the phenomenon when loading classes programmatically, classes to load are not visible to default class loaders, can be solved by using context class loader")])])]),e._v(" "),t("li",[e._v("class loaders as namespaces — class equality is determined by its full name "),t("strong",[e._v("and")]),e._v(" the class loader\n"),t("ul",[t("li",[e._v("equality — "),t("code",[e._v("Class::equals")]),e._v(", "),t("code",[e._v("Class::isAssignableFrom")]),e._v(", "),t("code",[e._v("Class::isInstance")]),e._v(", "),t("code",[e._v("instanceof")])]),e._v(" "),t("li",[e._v("use — useful for loading code from multiple sources, hot deployment etc.")])])]),e._v(" "),t("li",[e._v("Class Data Sharing (CDS) — share common classes across different JVM instances and improve JVM start speed")])])]),e._v(" "),t("li",[t("p",[e._v("class loading trigger")]),e._v(" "),t("ul",[t("li",[e._v("主动引用 — must load the class for those references\n"),t("ul",[t("li",[e._v("when bytecode "),t("code",[e._v("new")]),e._v(", "),t("code",[e._v("getstatc")]),e._v(", "),t("code",[e._v("putstataic")]),e._v(", "),t("code",[e._v("invokestatic")])]),e._v(" "),t("li",[t("code",[e._v("java.lang.reflect")])]),e._v(" "),t("li",[e._v("parent classes must be loaded before loading subclasses")]),e._v(" "),t("li",[t("code",[e._v("main")]),e._v(" method class when starting")]),e._v(" "),t("li",[t("code",[e._v("java.lang.invoke.MethodHandle")])])])]),e._v(" "),t("li",[e._v("被动引用 — will not trigger class loading\n"),t("ul",[t("li",[e._v("the subclass when referring to a static field of superclass from a subclass")]),e._v(" "),t("li",[e._v("the class as the type of elements of an array")]),e._v(" "),t("li",[e._v("the class when referring to constants, as constants held in constant pool of the invoking class")])])])])]),e._v(" "),t("li",[t("p",[t("code",[e._v("ClassLoader")])]),e._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("public")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("abstract")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("class")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("ClassLoader")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("extends")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Object")]),e._v("\n")])])]),t("ul",[t("li",[e._v("creation\n"),t("ul",[t("li",[t("code",[e._v("Class::getClassLoader")])])])]),e._v(" "),t("li",[e._v("assertion\n"),t("ul",[t("li",[t("code",[e._v("void clearAssertionStatus()")])]),e._v(" "),t("li",[t("code",[e._v("void setClassAssertionStatus(String className, boolean enabled)")])]),e._v(" "),t("li",[t("code",[e._v("void setDefaultAssertionStatus(boolean enabled)")])]),e._v(" "),t("li",[t("code",[e._v("void setPackageAssertionStatus(String packageName, boolean enabled)")])])])]),e._v(" "),t("li",[e._v("load classes\n"),t("ul",[t("li",[t("code",[e._v("protected Class<?> loadClass(String name, boolean resolve)")]),e._v(" — Loads the class with the specified binary name, in below order\n"),t("ol",[t("li",[t("code",[e._v("protected final Class<?> findLoadedClass(String name)")])]),e._v(" "),t("li",[t("code",[e._v("loadClass")]),e._v(" of the parent class loader or the build-in JVM class loader if the parent is "),t("code",[e._v("null")])]),e._v(" "),t("li",[t("code",[e._v("protected Class<?> findClass​(String name)")]),e._v(" — for overloading with own implementation")])])]),e._v(" "),t("li",[t("code",[e._v("protected final Class<?> defineClass(...)")]),e._v(" — convert bytes to classes, typically used by "),t("code",[e._v("findClass")])])])])])]),e._v(" "),t("li",[t("p",[t("code",[e._v("java.net.URLClassLoader")])]),e._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("public")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("class")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("URLClassLoader")]),e._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("extends")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("SecureClassLoader")]),e._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("implements")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Closeable")]),e._v("\n")])])]),t("ul",[t("li",[e._v("example usage"),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("URL")]),e._v(" url "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("new")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("URL")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[e._v('"file:///path/to/plugin.jar"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),t("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("URLClassLoader")]),e._v(" pluginLoader "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("new")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("URLClassLoader")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("new")]),e._v(" URL"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v(" url "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),t("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Class")]),t("span",{pre:!0,attrs:{class:"token generics"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("<")]),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("?")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(">")])]),e._v(" cl "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" pluginLoader"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("loadClass")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[e._v('"mypackage.MyClass"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])])])])])])])])}),[],!1,null,null,null);a.default=r.exports}}]);